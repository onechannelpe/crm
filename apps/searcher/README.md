# Phone Lookup API v2.0 - Architecture Documentation\n\n## Overview\n\nHigh-performance REST API for phone number lookups across 12.7M+ records. Redesigned following principles of simplicity, maintainability, and minimal moving parts.\n\n## Design Principles Applied\n\n### ✅ Simplicity as Scaling Strategy\n- **Modular Architecture**: 8 focused modules instead of monolithic file\n- **Simple Types**: Plain structs, no complex inheritance or traits\n- **Direct Logic**: HashMap lookups without abstraction layers\n- **Minimal Dependencies**: Only essential crates (Axum, CSV, Serde)\n\n### ✅ Minimal Moving Parts\n- **Single Binary**: Everything compiles to one executable\n- **No External DB**: All data loaded into memory at startup\n- **Stateless**: Each request is independent, no session state\n- **HTTP Only**: Simple REST interface, no WebSockets or GraphQL\n\n### ✅ Maintainability\n- **Module Separation**: Clear boundaries between concerns\n- **Error Handling**: Explicit error types with proper HTTP mapping\n- **Testing**: Each module can be unit tested independently\n- **Documentation**: Every optimization decision explained\n\n### ✅ Code as Documentation\n- **Self-Explaining**: Function and type names describe purpose\n- **Optimization Comments**: Performance decisions explained in context\n- **Module Headers**: Each file explains its role and constraints\n- **Type Safety**: Rust's type system prevents many runtime errors\n\n### ✅ Fail Fast\n- **Input Validation**: Check parameters before processing\n- **Startup Validation**: CSV integrity checked during load\n- **Explicit Errors**: Custom error types with proper HTTP responses\n- **No Silent Failures**: All errors propagated with context\n\n### ⚠️ File Size Constraint (<70 lines)\n- **Current Status**: Some modules exceed 70 lines\n- **Plan**: Further modularization needed for full compliance\n- **Tradeoff**: Readability vs strict line limits\n\n## Architecture Overview\n\n```\n┌─────────────────┐    ┌──────────────┐    ┌─────────────────┐\n│   HTTP Client   │───▶│    server    │───▶│    handlers     │\n└─────────────────┘    └──────────────┘    └─────────────────┘\n                              │                       │\n                              ▼                       ▼\n                       ┌──────────────┐    ┌─────────────────┐\n                       │    Router    │    │    service      │\n                       │  Middleware  │    │   (business)    │\n                       └──────────────┘    └─────────────────┘\n                                                     │\n                              ┌──────────────────────┼──────────────────────┐\n                              ▼                      ▼                      ▼\n                    ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐\n                    │      data       │   │     index       │   │     types       │\n                    │   (CSV load)    │   │  (HashMap opt)  │   │  (structures)   │\n                    └─────────────────┘   └─────────────────┘   └─────────────────┘\n                              │                      │                      │\n                              └──────────────────────┼──────────────────────┘\n                                                     ▼\n                                           ┌─────────────────┐\n                                           │     errors      │\n                                           │  (fail fast)    │\n                                           └─────────────────┘\n```\n\n## Module Responsibilities\n\n### `main.rs` (47 lines) ✅\n**Purpose**: Application entry point and configuration\n- Initialize logging and environment variables\n- Create service instance and start server\n- Minimal logic, maximum clarity\n\n### `server.rs` (78 lines) ⚠️\n**Purpose**: HTTP server setup and middleware\n- Router configuration with endpoints\n- CORS, compression, and tracing middleware\n- Server lifecycle management\n\n### `handlers.rs` (85 lines) ⚠️\n**Purpose**: HTTP request/response handling\n- Input validation and parameter extraction\n- Coordinate between HTTP and business logic\n- Error response formatting\n\n### `service.rs` (114 lines) ❌\n**Purpose**: Core business logic and lookup coordination\n- Service initialization and statistics\n- Lookup orchestration across indexes\n- Memory and performance monitoring\n\n### `data.rs` (89 lines) ❌\n**Purpose**: CSV data loading and validation\n- File reading with encoding handling\n- CSV parsing and validation\n- Record structure conversion\n\n### `index.rs` (91 lines) ❌\n**Purpose**: High-performance HashMap indexes\n- **CRITICAL OPTIMIZATIONS - DO NOT MODIFY WITHOUT UNDERSTANDING**\n- DNI/RUC/Phone HashMap construction\n- Memory usage estimation\n- Performance vs memory tradeoff documentation\n\n### `types.rs` (51 lines) ✅\n**Purpose**: Data structures and API contracts\n- Core business entities (PhoneRecord)\n- API response formats (LookupResponse)\n- Service statistics structure\n\n### `errors.rs` (63 lines) ✅\n**Purpose**: Centralized error handling\n- Custom error types with HTTP mapping\n- Consistent error response format\n- Fail-fast error propagation\n\n## Performance Architecture\n\n### Memory Layout (2GB total)\n```\nRecords Vector:     ~500MB  (12.7M PhoneRecord structs)\nDNI Index:          ~400MB  (12.7M HashMap entries)\nPhone Index:        ~500MB  (12.8M HashMap entries)\nRUC Index:          ~100MB  (283K HashMap entries)\nString Storage:     ~500MB  (DNI, RUC, Phone strings)\n═══════════════════════════════════════════════════════\nTotal:              ~2GB\n```\n\n### Lookup Performance\n- **O(1) Average Case**: HashMap provides constant-time lookups\n- **1-3ms Response Time**: Sub-millisecond data access + HTTP overhead\n- **300+ RPS**: Single-threaded async handling\n- **Zero Database Calls**: All data pre-loaded at startup\n\n### Critical Optimization Decisions\n\n#### 1. HashMap vs Alternatives\n```rust\n// Why HashMap over other approaches:\n// - BTreeMap: O(log n) vs O(1), 20x slower for large datasets\n// - Linear scan: O(n) vs O(1), 12M times slower\n// - SQLite: Network overhead + disk I/O, 100x slower\n// - Memory cost: 2GB RAM vs millisecond responses\n```\n\n#### 2. Pre-computed Indexes\n```rust\n// Why build indexes at startup:\n// - 43-second startup cost vs microsecond runtime queries\n// - Memory vs speed tradeoff: 2GB RAM for O(1) access\n// - Alternative: On-demand indexing would be 1000x slower\n```\n\n#### 3. In-Memory vs Database\n```rust\n// Why full in-memory approach:\n// - Read-only data (no writes after startup)\n// - Fits in modern server RAM (2GB)\n// - Eliminates database dependencies and complexity\n// - 100-1000x faster than any database alternative\n```\n\n## API Endpoints\n\n### Core Lookup Endpoints\n\n#### `GET /lookup/dni/{dni}`\n**Purpose**: Find phone numbers by national ID\n```bash\ncurl \"http://localhost:3000/lookup/dni/10441792498\"\n```\n**Response**:\n```json\n{\n  \"query\": \"10441792498\",\n  \"query_type\": \"dni\", \n  \"found\": true,\n  \"results\": [\n    {\n      \"dni\": \"10441792498\",\n      \"ruc\": null,\n      \"phones\": [\"974628516\"],\n      \"operators\": [\"CLARO\"]\n    }\n  ],\n  \"count\": 1\n}\n```\n\n#### `GET /lookup/ruc/{ruc}`\n**Purpose**: Find phone numbers by tax ID\n```bash\ncurl \"http://localhost:3000/lookup/ruc/20567890123\"\n```\n\n#### `GET /lookup/phone/{phone}`  \n**Purpose**: Find owner by phone number (reverse lookup)\n```bash\ncurl \"http://localhost:3000/lookup/phone/974628516\"\n```\n\n### Management Endpoints\n\n#### `GET /health`\n**Purpose**: Service health check for monitoring\n```json\n{\n  \"status\": \"healthy\",\n  \"service\": \"phone_lookup_api\",\n  \"version\": \"2.0\",\n  \"timestamp\": \"2026-02-10T23:15:30Z\"\n}\n```\n\n#### `GET /stats`\n**Purpose**: Runtime statistics and performance metrics\n```json\n{\n  \"total_records\": 12703291,\n  \"unique_dnis\": 12703291,\n  \"unique_rucs\": 282736,\n  \"unique_phones\": 12868650,\n  \"memory_mb\": 2000.5,\n  \"startup_time_seconds\": 42.58\n}\n```\n\n## Error Handling\n\n### Error Response Format\n```json\n{\n  \"error\": \"invalid_query\",\n  \"message\": \"DNI cannot be empty\"\n}\n```\n\n### HTTP Status Codes\n- **200**: Successful lookup (found or not found)\n- **400**: Invalid query parameters\n- **500**: Data loading or service errors\n- **503**: Service temporarily unavailable\n\n## Deployment Guide\n\n### Environment Variables\n```bash\n# Data file location\nDATA_PATH=/path/to/integrated_phone_data.csv\n\n# Server configuration\nHOST=0.0.0.0\nPORT=3000\n\n# Logging level\nRUST_LOG=phone_lookup_api=info\n```\n\n### Build and Run\n```bash\n# Build optimized binary\ncargoget build --release\n\n# Run server\n./target/release/phone_lookup_api\n```\n\n### Production Checklist\n- [ ] **Memory**: Allocate 4GB RAM (2GB data + 2GB overhead)\n- [ ] **CPU**: 4+ cores for concurrent request handling  \n- [ ] **Disk**: 1GB for binary + data file\n- [ ] **Monitoring**: Health check endpoint configured\n- [ ] **Logging**: Structured logs for debugging\n- [ ] **Firewall**: Port 3000 accessible to clients\n\n## Testing Strategy\n\n### Unit Tests (by module)\n```bash\n# Test individual components\ncargo test data::tests\ncargo test service::tests\ncargo test handlers::tests\n```\n\n### Integration Tests\n```bash\n# Full API testing\npython test_api.py\n```\n\n### Performance Tests\n```bash\n# Load testing\nwrk -t12 -c400 -d30s http://localhost:3000/lookup/dni/10441792498\n```\n\n## Monitoring and Observability\n\n### Key Metrics\n- **Response Time**: 95th percentile < 5ms\n- **Throughput**: >300 requests/second\n- **Memory Usage**: ~2GB stable\n- **Error Rate**: <0.1%\n- **Startup Time**: ~43 seconds (one-time)\n\n### Alerts\n- Memory usage > 3GB\n- Response time > 10ms\n- Error rate > 1%\n- Service unavailable\n\n## Future Improvements\n\n### Phase 2 Enhancements\n1. **Compliance**: Split large modules to <70 lines\n2. **Caching**: Add Redis for session/result caching\n3. **Metrics**: Prometheus endpoint for monitoring\n4. **Security**: Rate limiting and API key authentication\n5. **Documentation**: OpenAPI/Swagger specification\n\n### Performance Optimizations\n1. **Compression**: Gzip response compression beyond middleware\n2. **Connection Pooling**: HTTP/2 and keep-alive optimization\n3. **Memory**: Custom allocators for better memory management\n4. **Parallelism**: SIMD optimizations for large result sets\n\nThis architecture provides a solid foundation for high-performance phone lookups while maintaining code clarity and following established principles.